// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: rdb_protocol/ql2.proto

#ifndef PROTOBUF_rdb_5fprotocol_2fql2_2eproto__INCLUDED
#define PROTOBUF_rdb_5fprotocol_2fql2_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_rdb_5fprotocol_2fql2_2eproto();
void protobuf_AssignDesc_rdb_5fprotocol_2fql2_2eproto();
void protobuf_ShutdownFile_rdb_5fprotocol_2fql2_2eproto();

class Backtrace;
class Datum;
class Datum_AssocPair;
class Frame;
class Query;
class Query_AssocPair;
class Response;
class Term;
class Term_AssocPair;
class VersionDummy;

enum VersionDummy_Version {
  VersionDummy_Version_V0_1 = 1063369270,
  VersionDummy_Version_V0_2 = 1915781601,
  VersionDummy_Version_V0_3 = 1601562686,
  VersionDummy_Version_V0_4 = 1074539808,
  VersionDummy_Version_V1_0 = 885177795
};
bool VersionDummy_Version_IsValid(int value);
const VersionDummy_Version VersionDummy_Version_Version_MIN = VersionDummy_Version_V1_0;
const VersionDummy_Version VersionDummy_Version_Version_MAX = VersionDummy_Version_V0_2;
const int VersionDummy_Version_Version_ARRAYSIZE = VersionDummy_Version_Version_MAX + 1;

const ::google::protobuf::EnumDescriptor* VersionDummy_Version_descriptor();
inline const ::std::string& VersionDummy_Version_Name(VersionDummy_Version value) {
  return ::google::protobuf::internal::NameOfEnum(
    VersionDummy_Version_descriptor(), value);
}
inline bool VersionDummy_Version_Parse(
    const ::std::string& name, VersionDummy_Version* value) {
  return ::google::protobuf::internal::ParseNamedEnum<VersionDummy_Version>(
    VersionDummy_Version_descriptor(), name, value);
}
enum VersionDummy_Protocol {
  VersionDummy_Protocol_PROTOBUF = 656407617,
  VersionDummy_Protocol_JSON = 2120839367
};
bool VersionDummy_Protocol_IsValid(int value);
const VersionDummy_Protocol VersionDummy_Protocol_Protocol_MIN = VersionDummy_Protocol_PROTOBUF;
const VersionDummy_Protocol VersionDummy_Protocol_Protocol_MAX = VersionDummy_Protocol_JSON;
const int VersionDummy_Protocol_Protocol_ARRAYSIZE = VersionDummy_Protocol_Protocol_MAX + 1;

const ::google::protobuf::EnumDescriptor* VersionDummy_Protocol_descriptor();
inline const ::std::string& VersionDummy_Protocol_Name(VersionDummy_Protocol value) {
  return ::google::protobuf::internal::NameOfEnum(
    VersionDummy_Protocol_descriptor(), value);
}
inline bool VersionDummy_Protocol_Parse(
    const ::std::string& name, VersionDummy_Protocol* value) {
  return ::google::protobuf::internal::ParseNamedEnum<VersionDummy_Protocol>(
    VersionDummy_Protocol_descriptor(), name, value);
}
enum Query_QueryType {
  Query_QueryType_START = 1,
  Query_QueryType_CONTINUE = 2,
  Query_QueryType_STOP = 3,
  Query_QueryType_NOREPLY_WAIT = 4,
  Query_QueryType_SERVER_INFO = 5
};
bool Query_QueryType_IsValid(int value);
const Query_QueryType Query_QueryType_QueryType_MIN = Query_QueryType_START;
const Query_QueryType Query_QueryType_QueryType_MAX = Query_QueryType_SERVER_INFO;
const int Query_QueryType_QueryType_ARRAYSIZE = Query_QueryType_QueryType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Query_QueryType_descriptor();
inline const ::std::string& Query_QueryType_Name(Query_QueryType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Query_QueryType_descriptor(), value);
}
inline bool Query_QueryType_Parse(
    const ::std::string& name, Query_QueryType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Query_QueryType>(
    Query_QueryType_descriptor(), name, value);
}
enum Frame_FrameType {
  Frame_FrameType_POS = 1,
  Frame_FrameType_OPT = 2
};
bool Frame_FrameType_IsValid(int value);
const Frame_FrameType Frame_FrameType_FrameType_MIN = Frame_FrameType_POS;
const Frame_FrameType Frame_FrameType_FrameType_MAX = Frame_FrameType_OPT;
const int Frame_FrameType_FrameType_ARRAYSIZE = Frame_FrameType_FrameType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Frame_FrameType_descriptor();
inline const ::std::string& Frame_FrameType_Name(Frame_FrameType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Frame_FrameType_descriptor(), value);
}
inline bool Frame_FrameType_Parse(
    const ::std::string& name, Frame_FrameType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Frame_FrameType>(
    Frame_FrameType_descriptor(), name, value);
}
enum Response_ResponseType {
  Response_ResponseType_SUCCESS_ATOM = 1,
  Response_ResponseType_SUCCESS_SEQUENCE = 2,
  Response_ResponseType_SUCCESS_PARTIAL = 3,
  Response_ResponseType_WAIT_COMPLETE = 4,
  Response_ResponseType_SERVER_INFO = 5,
  Response_ResponseType_CLIENT_ERROR = 16,
  Response_ResponseType_COMPILE_ERROR = 17,
  Response_ResponseType_RUNTIME_ERROR = 18
};
bool Response_ResponseType_IsValid(int value);
const Response_ResponseType Response_ResponseType_ResponseType_MIN = Response_ResponseType_SUCCESS_ATOM;
const Response_ResponseType Response_ResponseType_ResponseType_MAX = Response_ResponseType_RUNTIME_ERROR;
const int Response_ResponseType_ResponseType_ARRAYSIZE = Response_ResponseType_ResponseType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Response_ResponseType_descriptor();
inline const ::std::string& Response_ResponseType_Name(Response_ResponseType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Response_ResponseType_descriptor(), value);
}
inline bool Response_ResponseType_Parse(
    const ::std::string& name, Response_ResponseType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Response_ResponseType>(
    Response_ResponseType_descriptor(), name, value);
}
enum Response_ErrorType {
  Response_ErrorType_INTERNAL = 1000000,
  Response_ErrorType_RESOURCE_LIMIT = 2000000,
  Response_ErrorType_QUERY_LOGIC = 3000000,
  Response_ErrorType_NON_EXISTENCE = 3100000,
  Response_ErrorType_OP_FAILED = 4100000,
  Response_ErrorType_OP_INDETERMINATE = 4200000,
  Response_ErrorType_USER = 5000000,
  Response_ErrorType_PERMISSION_ERROR = 6000000
};
bool Response_ErrorType_IsValid(int value);
const Response_ErrorType Response_ErrorType_ErrorType_MIN = Response_ErrorType_INTERNAL;
const Response_ErrorType Response_ErrorType_ErrorType_MAX = Response_ErrorType_PERMISSION_ERROR;
const int Response_ErrorType_ErrorType_ARRAYSIZE = Response_ErrorType_ErrorType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Response_ErrorType_descriptor();
inline const ::std::string& Response_ErrorType_Name(Response_ErrorType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Response_ErrorType_descriptor(), value);
}
inline bool Response_ErrorType_Parse(
    const ::std::string& name, Response_ErrorType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Response_ErrorType>(
    Response_ErrorType_descriptor(), name, value);
}
enum Response_ResponseNote {
  Response_ResponseNote_SEQUENCE_FEED = 1,
  Response_ResponseNote_ATOM_FEED = 2,
  Response_ResponseNote_ORDER_BY_LIMIT_FEED = 3,
  Response_ResponseNote_UNIONED_FEED = 4,
  Response_ResponseNote_INCLUDES_STATES = 5
};
bool Response_ResponseNote_IsValid(int value);
const Response_ResponseNote Response_ResponseNote_ResponseNote_MIN = Response_ResponseNote_SEQUENCE_FEED;
const Response_ResponseNote Response_ResponseNote_ResponseNote_MAX = Response_ResponseNote_INCLUDES_STATES;
const int Response_ResponseNote_ResponseNote_ARRAYSIZE = Response_ResponseNote_ResponseNote_MAX + 1;

const ::google::protobuf::EnumDescriptor* Response_ResponseNote_descriptor();
inline const ::std::string& Response_ResponseNote_Name(Response_ResponseNote value) {
  return ::google::protobuf::internal::NameOfEnum(
    Response_ResponseNote_descriptor(), value);
}
inline bool Response_ResponseNote_Parse(
    const ::std::string& name, Response_ResponseNote* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Response_ResponseNote>(
    Response_ResponseNote_descriptor(), name, value);
}
enum Datum_DatumType {
  Datum_DatumType_R_NULL = 1,
  Datum_DatumType_R_BOOL = 2,
  Datum_DatumType_R_NUM = 3,
  Datum_DatumType_R_STR = 4,
  Datum_DatumType_R_ARRAY = 5,
  Datum_DatumType_R_OBJECT = 6,
  Datum_DatumType_R_JSON = 7
};
bool Datum_DatumType_IsValid(int value);
const Datum_DatumType Datum_DatumType_DatumType_MIN = Datum_DatumType_R_NULL;
const Datum_DatumType Datum_DatumType_DatumType_MAX = Datum_DatumType_R_JSON;
const int Datum_DatumType_DatumType_ARRAYSIZE = Datum_DatumType_DatumType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Datum_DatumType_descriptor();
inline const ::std::string& Datum_DatumType_Name(Datum_DatumType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Datum_DatumType_descriptor(), value);
}
inline bool Datum_DatumType_Parse(
    const ::std::string& name, Datum_DatumType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Datum_DatumType>(
    Datum_DatumType_descriptor(), name, value);
}
enum Term_TermType {
  Term_TermType_DATUM = 1,
  Term_TermType_MAKE_ARRAY = 2,
  Term_TermType_MAKE_OBJ = 3,
  Term_TermType_VAR = 10,
  Term_TermType_JAVASCRIPT = 11,
  Term_TermType_UUID = 169,
  Term_TermType_HTTP = 153,
  Term_TermType_ERROR = 12,
  Term_TermType_IMPLICIT_VAR = 13,
  Term_TermType_DB = 14,
  Term_TermType_TABLE = 15,
  Term_TermType_GET = 16,
  Term_TermType_GET_ALL = 78,
  Term_TermType_EQ = 17,
  Term_TermType_NE = 18,
  Term_TermType_LT = 19,
  Term_TermType_LE = 20,
  Term_TermType_GT = 21,
  Term_TermType_GE = 22,
  Term_TermType_NOT = 23,
  Term_TermType_ADD = 24,
  Term_TermType_SUB = 25,
  Term_TermType_MUL = 26,
  Term_TermType_DIV = 27,
  Term_TermType_MOD = 28,
  Term_TermType_FLOOR = 183,
  Term_TermType_CEIL = 184,
  Term_TermType_ROUND = 185,
  Term_TermType_APPEND = 29,
  Term_TermType_PREPEND = 80,
  Term_TermType_DIFFERENCE = 95,
  Term_TermType_SET_INSERT = 88,
  Term_TermType_SET_INTERSECTION = 89,
  Term_TermType_SET_UNION = 90,
  Term_TermType_SET_DIFFERENCE = 91,
  Term_TermType_SLICE = 30,
  Term_TermType_SKIP = 70,
  Term_TermType_LIMIT = 71,
  Term_TermType_OFFSETS_OF = 87,
  Term_TermType_CONTAINS = 93,
  Term_TermType_GET_FIELD = 31,
  Term_TermType_KEYS = 94,
  Term_TermType_VALUES = 186,
  Term_TermType_OBJECT = 143,
  Term_TermType_HAS_FIELDS = 32,
  Term_TermType_WITH_FIELDS = 96,
  Term_TermType_PLUCK = 33,
  Term_TermType_WITHOUT = 34,
  Term_TermType_MERGE = 35,
  Term_TermType_BETWEEN_DEPRECATED = 36,
  Term_TermType_BETWEEN = 182,
  Term_TermType_REDUCE = 37,
  Term_TermType_MAP = 38,
  Term_TermType_FOLD = 187,
  Term_TermType_FILTER = 39,
  Term_TermType_CONCAT_MAP = 40,
  Term_TermType_ORDER_BY = 41,
  Term_TermType_DISTINCT = 42,
  Term_TermType_COUNT = 43,
  Term_TermType_IS_EMPTY = 86,
  Term_TermType_UNION = 44,
  Term_TermType_NTH = 45,
  Term_TermType_BRACKET = 170,
  Term_TermType_INNER_JOIN = 48,
  Term_TermType_OUTER_JOIN = 49,
  Term_TermType_EQ_JOIN = 50,
  Term_TermType_ZIP = 72,
  Term_TermType_RANGE = 173,
  Term_TermType_INSERT_AT = 82,
  Term_TermType_DELETE_AT = 83,
  Term_TermType_CHANGE_AT = 84,
  Term_TermType_SPLICE_AT = 85,
  Term_TermType_COERCE_TO = 51,
  Term_TermType_TYPE_OF = 52,
  Term_TermType_UPDATE = 53,
  Term_TermType_DELETE = 54,
  Term_TermType_REPLACE = 55,
  Term_TermType_INSERT = 56,
  Term_TermType_DB_CREATE = 57,
  Term_TermType_DB_DROP = 58,
  Term_TermType_DB_LIST = 59,
  Term_TermType_TABLE_CREATE = 60,
  Term_TermType_TABLE_DROP = 61,
  Term_TermType_TABLE_LIST = 62,
  Term_TermType_CONFIG = 174,
  Term_TermType_STATUS = 175,
  Term_TermType_WAIT = 177,
  Term_TermType_RECONFIGURE = 176,
  Term_TermType_REBALANCE = 179,
  Term_TermType_SYNC = 138,
  Term_TermType_GRANT = 188,
  Term_TermType_INDEX_CREATE = 75,
  Term_TermType_INDEX_DROP = 76,
  Term_TermType_INDEX_LIST = 77,
  Term_TermType_INDEX_STATUS = 139,
  Term_TermType_INDEX_WAIT = 140,
  Term_TermType_INDEX_RENAME = 156,
  Term_TermType_SET_WRITE_HOOK = 189,
  Term_TermType_GET_WRITE_HOOK = 190,
  Term_TermType_FUNCALL = 64,
  Term_TermType_BRANCH = 65,
  Term_TermType_OR = 66,
  Term_TermType_AND = 67,
  Term_TermType_FOR_EACH = 68,
  Term_TermType_FUNC = 69,
  Term_TermType_ASC = 73,
  Term_TermType_DESC = 74,
  Term_TermType_INFO = 79,
  Term_TermType_MATCH = 97,
  Term_TermType_UPCASE = 141,
  Term_TermType_DOWNCASE = 142,
  Term_TermType_SAMPLE = 81,
  Term_TermType_DEFAULT = 92,
  Term_TermType_JSON = 98,
  Term_TermType_ISO8601 = 99,
  Term_TermType_TO_ISO8601 = 100,
  Term_TermType_EPOCH_TIME = 101,
  Term_TermType_TO_EPOCH_TIME = 102,
  Term_TermType_NOW = 103,
  Term_TermType_IN_TIMEZONE = 104,
  Term_TermType_DURING = 105,
  Term_TermType_DATE = 106,
  Term_TermType_TIME_OF_DAY = 126,
  Term_TermType_TIMEZONE = 127,
  Term_TermType_YEAR = 128,
  Term_TermType_MONTH = 129,
  Term_TermType_DAY = 130,
  Term_TermType_DAY_OF_WEEK = 131,
  Term_TermType_DAY_OF_YEAR = 132,
  Term_TermType_HOURS = 133,
  Term_TermType_MINUTES = 134,
  Term_TermType_SECONDS = 135,
  Term_TermType_TIME = 136,
  Term_TermType_MONDAY = 107,
  Term_TermType_TUESDAY = 108,
  Term_TermType_WEDNESDAY = 109,
  Term_TermType_THURSDAY = 110,
  Term_TermType_FRIDAY = 111,
  Term_TermType_SATURDAY = 112,
  Term_TermType_SUNDAY = 113,
  Term_TermType_JANUARY = 114,
  Term_TermType_FEBRUARY = 115,
  Term_TermType_MARCH = 116,
  Term_TermType_APRIL = 117,
  Term_TermType_MAY = 118,
  Term_TermType_JUNE = 119,
  Term_TermType_JULY = 120,
  Term_TermType_AUGUST = 121,
  Term_TermType_SEPTEMBER = 122,
  Term_TermType_OCTOBER = 123,
  Term_TermType_NOVEMBER = 124,
  Term_TermType_DECEMBER = 125,
  Term_TermType_LITERAL = 137,
  Term_TermType_GROUP = 144,
  Term_TermType_SUM = 145,
  Term_TermType_AVG = 146,
  Term_TermType_MIN = 147,
  Term_TermType_MAX = 148,
  Term_TermType_SPLIT = 149,
  Term_TermType_UNGROUP = 150,
  Term_TermType_RANDOM = 151,
  Term_TermType_CHANGES = 152,
  Term_TermType_ARGS = 154,
  Term_TermType_BINARY = 155,
  Term_TermType_GEOJSON = 157,
  Term_TermType_TO_GEOJSON = 158,
  Term_TermType_POINT = 159,
  Term_TermType_LINE = 160,
  Term_TermType_POLYGON = 161,
  Term_TermType_DISTANCE = 162,
  Term_TermType_INTERSECTS = 163,
  Term_TermType_INCLUDES = 164,
  Term_TermType_CIRCLE = 165,
  Term_TermType_GET_INTERSECTING = 166,
  Term_TermType_FILL = 167,
  Term_TermType_GET_NEAREST = 168,
  Term_TermType_POLYGON_SUB = 171,
  Term_TermType_TO_JSON_STRING = 172,
  Term_TermType_MINVAL = 180,
  Term_TermType_MAXVAL = 181,
  Term_TermType_BIT_AND = 191,
  Term_TermType_BIT_OR = 192,
  Term_TermType_BIT_XOR = 193,
  Term_TermType_BIT_NOT = 194,
  Term_TermType_BIT_SAL = 195,
  Term_TermType_BIT_SAR = 196
};
bool Term_TermType_IsValid(int value);
const Term_TermType Term_TermType_TermType_MIN = Term_TermType_DATUM;
const Term_TermType Term_TermType_TermType_MAX = Term_TermType_BIT_SAR;
const int Term_TermType_TermType_ARRAYSIZE = Term_TermType_TermType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Term_TermType_descriptor();
inline const ::std::string& Term_TermType_Name(Term_TermType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Term_TermType_descriptor(), value);
}
inline bool Term_TermType_Parse(
    const ::std::string& name, Term_TermType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Term_TermType>(
    Term_TermType_descriptor(), name, value);
}
// ===================================================================

class VersionDummy : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:VersionDummy) */ {
 public:
  VersionDummy();
  virtual ~VersionDummy();

  VersionDummy(const VersionDummy& from);

  inline VersionDummy& operator=(const VersionDummy& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VersionDummy& default_instance();

  void Swap(VersionDummy* other);

  // implements Message ----------------------------------------------

  inline VersionDummy* New() const { return New(NULL); }

  VersionDummy* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VersionDummy& from);
  void MergeFrom(const VersionDummy& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(VersionDummy* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef VersionDummy_Version Version;
  static const Version V0_1 =
    VersionDummy_Version_V0_1;
  static const Version V0_2 =
    VersionDummy_Version_V0_2;
  static const Version V0_3 =
    VersionDummy_Version_V0_3;
  static const Version V0_4 =
    VersionDummy_Version_V0_4;
  static const Version V1_0 =
    VersionDummy_Version_V1_0;
  static inline bool Version_IsValid(int value) {
    return VersionDummy_Version_IsValid(value);
  }
  static const Version Version_MIN =
    VersionDummy_Version_Version_MIN;
  static const Version Version_MAX =
    VersionDummy_Version_Version_MAX;
  static const int Version_ARRAYSIZE =
    VersionDummy_Version_Version_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Version_descriptor() {
    return VersionDummy_Version_descriptor();
  }
  static inline const ::std::string& Version_Name(Version value) {
    return VersionDummy_Version_Name(value);
  }
  static inline bool Version_Parse(const ::std::string& name,
      Version* value) {
    return VersionDummy_Version_Parse(name, value);
  }

  typedef VersionDummy_Protocol Protocol;
  static const Protocol PROTOBUF =
    VersionDummy_Protocol_PROTOBUF;
  static const Protocol JSON =
    VersionDummy_Protocol_JSON;
  static inline bool Protocol_IsValid(int value) {
    return VersionDummy_Protocol_IsValid(value);
  }
  static const Protocol Protocol_MIN =
    VersionDummy_Protocol_Protocol_MIN;
  static const Protocol Protocol_MAX =
    VersionDummy_Protocol_Protocol_MAX;
  static const int Protocol_ARRAYSIZE =
    VersionDummy_Protocol_Protocol_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Protocol_descriptor() {
    return VersionDummy_Protocol_descriptor();
  }
  static inline const ::std::string& Protocol_Name(Protocol value) {
    return VersionDummy_Protocol_Name(value);
  }
  static inline bool Protocol_Parse(const ::std::string& name,
      Protocol* value) {
    return VersionDummy_Protocol_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:VersionDummy)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_rdb_5fprotocol_2fql2_2eproto();
  friend void protobuf_AssignDesc_rdb_5fprotocol_2fql2_2eproto();
  friend void protobuf_ShutdownFile_rdb_5fprotocol_2fql2_2eproto();

  void InitAsDefaultInstance();
  static VersionDummy* default_instance_;
};
// -------------------------------------------------------------------

class Query_AssocPair : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Query.AssocPair) */ {
 public:
  Query_AssocPair();
  virtual ~Query_AssocPair();

  Query_AssocPair(const Query_AssocPair& from);

  inline Query_AssocPair& operator=(const Query_AssocPair& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Query_AssocPair& default_instance();

  void Swap(Query_AssocPair* other);

  // implements Message ----------------------------------------------

  inline Query_AssocPair* New() const { return New(NULL); }

  Query_AssocPair* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Query_AssocPair& from);
  void MergeFrom(const Query_AssocPair& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Query_AssocPair* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string key = 1;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // optional .Term val = 2;
  bool has_val() const;
  void clear_val();
  static const int kValFieldNumber = 2;
  const ::Term& val() const;
  ::Term* mutable_val();
  ::Term* release_val();
  void set_allocated_val(::Term* val);

  // @@protoc_insertion_point(class_scope:Query.AssocPair)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_val();
  inline void clear_has_val();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::Term* val_;
  friend void  protobuf_AddDesc_rdb_5fprotocol_2fql2_2eproto();
  friend void protobuf_AssignDesc_rdb_5fprotocol_2fql2_2eproto();
  friend void protobuf_ShutdownFile_rdb_5fprotocol_2fql2_2eproto();

  void InitAsDefaultInstance();
  static Query_AssocPair* default_instance_;
};
// -------------------------------------------------------------------

class Query : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Query) */ {
 public:
  Query();
  virtual ~Query();

  Query(const Query& from);

  inline Query& operator=(const Query& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Query& default_instance();

  void Swap(Query* other);

  // implements Message ----------------------------------------------

  inline Query* New() const { return New(NULL); }

  Query* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Query& from);
  void MergeFrom(const Query& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Query* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Query_AssocPair AssocPair;

  typedef Query_QueryType QueryType;
  static const QueryType START =
    Query_QueryType_START;
  static const QueryType CONTINUE =
    Query_QueryType_CONTINUE;
  static const QueryType STOP =
    Query_QueryType_STOP;
  static const QueryType NOREPLY_WAIT =
    Query_QueryType_NOREPLY_WAIT;
  static const QueryType SERVER_INFO =
    Query_QueryType_SERVER_INFO;
  static inline bool QueryType_IsValid(int value) {
    return Query_QueryType_IsValid(value);
  }
  static const QueryType QueryType_MIN =
    Query_QueryType_QueryType_MIN;
  static const QueryType QueryType_MAX =
    Query_QueryType_QueryType_MAX;
  static const int QueryType_ARRAYSIZE =
    Query_QueryType_QueryType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  QueryType_descriptor() {
    return Query_QueryType_descriptor();
  }
  static inline const ::std::string& QueryType_Name(QueryType value) {
    return Query_QueryType_Name(value);
  }
  static inline bool QueryType_Parse(const ::std::string& name,
      QueryType* value) {
    return Query_QueryType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .Query.QueryType type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::Query_QueryType type() const;
  void set_type(::Query_QueryType value);

  // optional .Term query = 2;
  bool has_query() const;
  void clear_query();
  static const int kQueryFieldNumber = 2;
  const ::Term& query() const;
  ::Term* mutable_query();
  ::Term* release_query();
  void set_allocated_query(::Term* query);

  // optional int64 token = 3;
  bool has_token() const;
  void clear_token();
  static const int kTokenFieldNumber = 3;
  ::google::protobuf::int64 token() const;
  void set_token(::google::protobuf::int64 value);

  // optional bool OBSOLETE_noreply = 4 [default = false];
  bool has_obsolete_noreply() const;
  void clear_obsolete_noreply();
  static const int kOBSOLETENoreplyFieldNumber = 4;
  bool obsolete_noreply() const;
  void set_obsolete_noreply(bool value);

  // optional bool accepts_r_json = 5 [default = false];
  bool has_accepts_r_json() const;
  void clear_accepts_r_json();
  static const int kAcceptsRJsonFieldNumber = 5;
  bool accepts_r_json() const;
  void set_accepts_r_json(bool value);

  // repeated .Query.AssocPair global_optargs = 6;
  int global_optargs_size() const;
  void clear_global_optargs();
  static const int kGlobalOptargsFieldNumber = 6;
  const ::Query_AssocPair& global_optargs(int index) const;
  ::Query_AssocPair* mutable_global_optargs(int index);
  ::Query_AssocPair* add_global_optargs();
  ::google::protobuf::RepeatedPtrField< ::Query_AssocPair >*
      mutable_global_optargs();
  const ::google::protobuf::RepeatedPtrField< ::Query_AssocPair >&
      global_optargs() const;

  // @@protoc_insertion_point(class_scope:Query)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_query();
  inline void clear_has_query();
  inline void set_has_token();
  inline void clear_has_token();
  inline void set_has_obsolete_noreply();
  inline void clear_has_obsolete_noreply();
  inline void set_has_accepts_r_json();
  inline void clear_has_accepts_r_json();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::Term* query_;
  ::google::protobuf::int64 token_;
  int type_;
  bool obsolete_noreply_;
  bool accepts_r_json_;
  ::google::protobuf::RepeatedPtrField< ::Query_AssocPair > global_optargs_;
  friend void  protobuf_AddDesc_rdb_5fprotocol_2fql2_2eproto();
  friend void protobuf_AssignDesc_rdb_5fprotocol_2fql2_2eproto();
  friend void protobuf_ShutdownFile_rdb_5fprotocol_2fql2_2eproto();

  void InitAsDefaultInstance();
  static Query* default_instance_;
};
// -------------------------------------------------------------------

class Frame : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Frame) */ {
 public:
  Frame();
  virtual ~Frame();

  Frame(const Frame& from);

  inline Frame& operator=(const Frame& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Frame& default_instance();

  void Swap(Frame* other);

  // implements Message ----------------------------------------------

  inline Frame* New() const { return New(NULL); }

  Frame* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Frame& from);
  void MergeFrom(const Frame& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Frame* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Frame_FrameType FrameType;
  static const FrameType POS =
    Frame_FrameType_POS;
  static const FrameType OPT =
    Frame_FrameType_OPT;
  static inline bool FrameType_IsValid(int value) {
    return Frame_FrameType_IsValid(value);
  }
  static const FrameType FrameType_MIN =
    Frame_FrameType_FrameType_MIN;
  static const FrameType FrameType_MAX =
    Frame_FrameType_FrameType_MAX;
  static const int FrameType_ARRAYSIZE =
    Frame_FrameType_FrameType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  FrameType_descriptor() {
    return Frame_FrameType_descriptor();
  }
  static inline const ::std::string& FrameType_Name(FrameType value) {
    return Frame_FrameType_Name(value);
  }
  static inline bool FrameType_Parse(const ::std::string& name,
      FrameType* value) {
    return Frame_FrameType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .Frame.FrameType type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::Frame_FrameType type() const;
  void set_type(::Frame_FrameType value);

  // optional int64 pos = 2;
  bool has_pos() const;
  void clear_pos();
  static const int kPosFieldNumber = 2;
  ::google::protobuf::int64 pos() const;
  void set_pos(::google::protobuf::int64 value);

  // optional string opt = 3;
  bool has_opt() const;
  void clear_opt();
  static const int kOptFieldNumber = 3;
  const ::std::string& opt() const;
  void set_opt(const ::std::string& value);
  void set_opt(const char* value);
  void set_opt(const char* value, size_t size);
  ::std::string* mutable_opt();
  ::std::string* release_opt();
  void set_allocated_opt(::std::string* opt);

  // @@protoc_insertion_point(class_scope:Frame)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_pos();
  inline void clear_has_pos();
  inline void set_has_opt();
  inline void clear_has_opt();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 pos_;
  ::google::protobuf::internal::ArenaStringPtr opt_;
  int type_;
  friend void  protobuf_AddDesc_rdb_5fprotocol_2fql2_2eproto();
  friend void protobuf_AssignDesc_rdb_5fprotocol_2fql2_2eproto();
  friend void protobuf_ShutdownFile_rdb_5fprotocol_2fql2_2eproto();

  void InitAsDefaultInstance();
  static Frame* default_instance_;
};
// -------------------------------------------------------------------

class Backtrace : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Backtrace) */ {
 public:
  Backtrace();
  virtual ~Backtrace();

  Backtrace(const Backtrace& from);

  inline Backtrace& operator=(const Backtrace& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Backtrace& default_instance();

  void Swap(Backtrace* other);

  // implements Message ----------------------------------------------

  inline Backtrace* New() const { return New(NULL); }

  Backtrace* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Backtrace& from);
  void MergeFrom(const Backtrace& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Backtrace* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Frame frames = 1;
  int frames_size() const;
  void clear_frames();
  static const int kFramesFieldNumber = 1;
  const ::Frame& frames(int index) const;
  ::Frame* mutable_frames(int index);
  ::Frame* add_frames();
  ::google::protobuf::RepeatedPtrField< ::Frame >*
      mutable_frames();
  const ::google::protobuf::RepeatedPtrField< ::Frame >&
      frames() const;

  // @@protoc_insertion_point(class_scope:Backtrace)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::Frame > frames_;
  friend void  protobuf_AddDesc_rdb_5fprotocol_2fql2_2eproto();
  friend void protobuf_AssignDesc_rdb_5fprotocol_2fql2_2eproto();
  friend void protobuf_ShutdownFile_rdb_5fprotocol_2fql2_2eproto();

  void InitAsDefaultInstance();
  static Backtrace* default_instance_;
};
// -------------------------------------------------------------------

class Response : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Response) */ {
 public:
  Response();
  virtual ~Response();

  Response(const Response& from);

  inline Response& operator=(const Response& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Response& default_instance();

  void Swap(Response* other);

  // implements Message ----------------------------------------------

  inline Response* New() const { return New(NULL); }

  Response* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Response& from);
  void MergeFrom(const Response& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Response* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Response_ResponseType ResponseType;
  static const ResponseType SUCCESS_ATOM =
    Response_ResponseType_SUCCESS_ATOM;
  static const ResponseType SUCCESS_SEQUENCE =
    Response_ResponseType_SUCCESS_SEQUENCE;
  static const ResponseType SUCCESS_PARTIAL =
    Response_ResponseType_SUCCESS_PARTIAL;
  static const ResponseType WAIT_COMPLETE =
    Response_ResponseType_WAIT_COMPLETE;
  static const ResponseType SERVER_INFO =
    Response_ResponseType_SERVER_INFO;
  static const ResponseType CLIENT_ERROR =
    Response_ResponseType_CLIENT_ERROR;
  static const ResponseType COMPILE_ERROR =
    Response_ResponseType_COMPILE_ERROR;
  static const ResponseType RUNTIME_ERROR =
    Response_ResponseType_RUNTIME_ERROR;
  static inline bool ResponseType_IsValid(int value) {
    return Response_ResponseType_IsValid(value);
  }
  static const ResponseType ResponseType_MIN =
    Response_ResponseType_ResponseType_MIN;
  static const ResponseType ResponseType_MAX =
    Response_ResponseType_ResponseType_MAX;
  static const int ResponseType_ARRAYSIZE =
    Response_ResponseType_ResponseType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ResponseType_descriptor() {
    return Response_ResponseType_descriptor();
  }
  static inline const ::std::string& ResponseType_Name(ResponseType value) {
    return Response_ResponseType_Name(value);
  }
  static inline bool ResponseType_Parse(const ::std::string& name,
      ResponseType* value) {
    return Response_ResponseType_Parse(name, value);
  }

  typedef Response_ErrorType ErrorType;
  static const ErrorType INTERNAL =
    Response_ErrorType_INTERNAL;
  static const ErrorType RESOURCE_LIMIT =
    Response_ErrorType_RESOURCE_LIMIT;
  static const ErrorType QUERY_LOGIC =
    Response_ErrorType_QUERY_LOGIC;
  static const ErrorType NON_EXISTENCE =
    Response_ErrorType_NON_EXISTENCE;
  static const ErrorType OP_FAILED =
    Response_ErrorType_OP_FAILED;
  static const ErrorType OP_INDETERMINATE =
    Response_ErrorType_OP_INDETERMINATE;
  static const ErrorType USER =
    Response_ErrorType_USER;
  static const ErrorType PERMISSION_ERROR =
    Response_ErrorType_PERMISSION_ERROR;
  static inline bool ErrorType_IsValid(int value) {
    return Response_ErrorType_IsValid(value);
  }
  static const ErrorType ErrorType_MIN =
    Response_ErrorType_ErrorType_MIN;
  static const ErrorType ErrorType_MAX =
    Response_ErrorType_ErrorType_MAX;
  static const int ErrorType_ARRAYSIZE =
    Response_ErrorType_ErrorType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ErrorType_descriptor() {
    return Response_ErrorType_descriptor();
  }
  static inline const ::std::string& ErrorType_Name(ErrorType value) {
    return Response_ErrorType_Name(value);
  }
  static inline bool ErrorType_Parse(const ::std::string& name,
      ErrorType* value) {
    return Response_ErrorType_Parse(name, value);
  }

  typedef Response_ResponseNote ResponseNote;
  static const ResponseNote SEQUENCE_FEED =
    Response_ResponseNote_SEQUENCE_FEED;
  static const ResponseNote ATOM_FEED =
    Response_ResponseNote_ATOM_FEED;
  static const ResponseNote ORDER_BY_LIMIT_FEED =
    Response_ResponseNote_ORDER_BY_LIMIT_FEED;
  static const ResponseNote UNIONED_FEED =
    Response_ResponseNote_UNIONED_FEED;
  static const ResponseNote INCLUDES_STATES =
    Response_ResponseNote_INCLUDES_STATES;
  static inline bool ResponseNote_IsValid(int value) {
    return Response_ResponseNote_IsValid(value);
  }
  static const ResponseNote ResponseNote_MIN =
    Response_ResponseNote_ResponseNote_MIN;
  static const ResponseNote ResponseNote_MAX =
    Response_ResponseNote_ResponseNote_MAX;
  static const int ResponseNote_ARRAYSIZE =
    Response_ResponseNote_ResponseNote_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ResponseNote_descriptor() {
    return Response_ResponseNote_descriptor();
  }
  static inline const ::std::string& ResponseNote_Name(ResponseNote value) {
    return Response_ResponseNote_Name(value);
  }
  static inline bool ResponseNote_Parse(const ::std::string& name,
      ResponseNote* value) {
    return Response_ResponseNote_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .Response.ResponseType type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::Response_ResponseType type() const;
  void set_type(::Response_ResponseType value);

  // optional .Response.ErrorType error_type = 7;
  bool has_error_type() const;
  void clear_error_type();
  static const int kErrorTypeFieldNumber = 7;
  ::Response_ErrorType error_type() const;
  void set_error_type(::Response_ErrorType value);

  // repeated .Response.ResponseNote notes = 6;
  int notes_size() const;
  void clear_notes();
  static const int kNotesFieldNumber = 6;
  ::Response_ResponseNote notes(int index) const;
  void set_notes(int index, ::Response_ResponseNote value);
  void add_notes(::Response_ResponseNote value);
  const ::google::protobuf::RepeatedField<int>& notes() const;
  ::google::protobuf::RepeatedField<int>* mutable_notes();

  // optional int64 token = 2;
  bool has_token() const;
  void clear_token();
  static const int kTokenFieldNumber = 2;
  ::google::protobuf::int64 token() const;
  void set_token(::google::protobuf::int64 value);

  // repeated .Datum response = 3;
  int response_size() const;
  void clear_response();
  static const int kResponseFieldNumber = 3;
  const ::Datum& response(int index) const;
  ::Datum* mutable_response(int index);
  ::Datum* add_response();
  ::google::protobuf::RepeatedPtrField< ::Datum >*
      mutable_response();
  const ::google::protobuf::RepeatedPtrField< ::Datum >&
      response() const;

  // optional .Backtrace backtrace = 4;
  bool has_backtrace() const;
  void clear_backtrace();
  static const int kBacktraceFieldNumber = 4;
  const ::Backtrace& backtrace() const;
  ::Backtrace* mutable_backtrace();
  ::Backtrace* release_backtrace();
  void set_allocated_backtrace(::Backtrace* backtrace);

  // optional .Datum profile = 5;
  bool has_profile() const;
  void clear_profile();
  static const int kProfileFieldNumber = 5;
  const ::Datum& profile() const;
  ::Datum* mutable_profile();
  ::Datum* release_profile();
  void set_allocated_profile(::Datum* profile);

  // @@protoc_insertion_point(class_scope:Response)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_error_type();
  inline void clear_has_error_type();
  inline void set_has_token();
  inline void clear_has_token();
  inline void set_has_backtrace();
  inline void clear_has_backtrace();
  inline void set_has_profile();
  inline void clear_has_profile();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int type_;
  int error_type_;
  ::google::protobuf::RepeatedField<int> notes_;
  ::google::protobuf::int64 token_;
  ::google::protobuf::RepeatedPtrField< ::Datum > response_;
  ::Backtrace* backtrace_;
  ::Datum* profile_;
  friend void  protobuf_AddDesc_rdb_5fprotocol_2fql2_2eproto();
  friend void protobuf_AssignDesc_rdb_5fprotocol_2fql2_2eproto();
  friend void protobuf_ShutdownFile_rdb_5fprotocol_2fql2_2eproto();

  void InitAsDefaultInstance();
  static Response* default_instance_;
};
// -------------------------------------------------------------------

class Datum_AssocPair : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Datum.AssocPair) */ {
 public:
  Datum_AssocPair();
  virtual ~Datum_AssocPair();

  Datum_AssocPair(const Datum_AssocPair& from);

  inline Datum_AssocPair& operator=(const Datum_AssocPair& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Datum_AssocPair& default_instance();

  void Swap(Datum_AssocPair* other);

  // implements Message ----------------------------------------------

  inline Datum_AssocPair* New() const { return New(NULL); }

  Datum_AssocPair* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Datum_AssocPair& from);
  void MergeFrom(const Datum_AssocPair& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Datum_AssocPair* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string key = 1;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // optional .Datum val = 2;
  bool has_val() const;
  void clear_val();
  static const int kValFieldNumber = 2;
  const ::Datum& val() const;
  ::Datum* mutable_val();
  ::Datum* release_val();
  void set_allocated_val(::Datum* val);

  // @@protoc_insertion_point(class_scope:Datum.AssocPair)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_val();
  inline void clear_has_val();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::Datum* val_;
  friend void  protobuf_AddDesc_rdb_5fprotocol_2fql2_2eproto();
  friend void protobuf_AssignDesc_rdb_5fprotocol_2fql2_2eproto();
  friend void protobuf_ShutdownFile_rdb_5fprotocol_2fql2_2eproto();

  void InitAsDefaultInstance();
  static Datum_AssocPair* default_instance_;
};
// -------------------------------------------------------------------

class Datum : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Datum) */ {
 public:
  Datum();
  virtual ~Datum();

  Datum(const Datum& from);

  inline Datum& operator=(const Datum& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Datum& default_instance();

  void Swap(Datum* other);

  // implements Message ----------------------------------------------

  inline Datum* New() const { return New(NULL); }

  Datum* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Datum& from);
  void MergeFrom(const Datum& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Datum* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Datum_AssocPair AssocPair;

  typedef Datum_DatumType DatumType;
  static const DatumType R_NULL =
    Datum_DatumType_R_NULL;
  static const DatumType R_BOOL =
    Datum_DatumType_R_BOOL;
  static const DatumType R_NUM =
    Datum_DatumType_R_NUM;
  static const DatumType R_STR =
    Datum_DatumType_R_STR;
  static const DatumType R_ARRAY =
    Datum_DatumType_R_ARRAY;
  static const DatumType R_OBJECT =
    Datum_DatumType_R_OBJECT;
  static const DatumType R_JSON =
    Datum_DatumType_R_JSON;
  static inline bool DatumType_IsValid(int value) {
    return Datum_DatumType_IsValid(value);
  }
  static const DatumType DatumType_MIN =
    Datum_DatumType_DatumType_MIN;
  static const DatumType DatumType_MAX =
    Datum_DatumType_DatumType_MAX;
  static const int DatumType_ARRAYSIZE =
    Datum_DatumType_DatumType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  DatumType_descriptor() {
    return Datum_DatumType_descriptor();
  }
  static inline const ::std::string& DatumType_Name(DatumType value) {
    return Datum_DatumType_Name(value);
  }
  static inline bool DatumType_Parse(const ::std::string& name,
      DatumType* value) {
    return Datum_DatumType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .Datum.DatumType type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::Datum_DatumType type() const;
  void set_type(::Datum_DatumType value);

  // optional bool r_bool = 2;
  bool has_r_bool() const;
  void clear_r_bool();
  static const int kRBoolFieldNumber = 2;
  bool r_bool() const;
  void set_r_bool(bool value);

  // optional double r_num = 3;
  bool has_r_num() const;
  void clear_r_num();
  static const int kRNumFieldNumber = 3;
  double r_num() const;
  void set_r_num(double value);

  // optional string r_str = 4;
  bool has_r_str() const;
  void clear_r_str();
  static const int kRStrFieldNumber = 4;
  const ::std::string& r_str() const;
  void set_r_str(const ::std::string& value);
  void set_r_str(const char* value);
  void set_r_str(const char* value, size_t size);
  ::std::string* mutable_r_str();
  ::std::string* release_r_str();
  void set_allocated_r_str(::std::string* r_str);

  // repeated .Datum r_array = 5;
  int r_array_size() const;
  void clear_r_array();
  static const int kRArrayFieldNumber = 5;
  const ::Datum& r_array(int index) const;
  ::Datum* mutable_r_array(int index);
  ::Datum* add_r_array();
  ::google::protobuf::RepeatedPtrField< ::Datum >*
      mutable_r_array();
  const ::google::protobuf::RepeatedPtrField< ::Datum >&
      r_array() const;

  // repeated .Datum.AssocPair r_object = 6;
  int r_object_size() const;
  void clear_r_object();
  static const int kRObjectFieldNumber = 6;
  const ::Datum_AssocPair& r_object(int index) const;
  ::Datum_AssocPair* mutable_r_object(int index);
  ::Datum_AssocPair* add_r_object();
  ::google::protobuf::RepeatedPtrField< ::Datum_AssocPair >*
      mutable_r_object();
  const ::google::protobuf::RepeatedPtrField< ::Datum_AssocPair >&
      r_object() const;

  // @@protoc_insertion_point(class_scope:Datum)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_r_bool();
  inline void clear_has_r_bool();
  inline void set_has_r_num();
  inline void clear_has_r_num();
  inline void set_has_r_str();
  inline void clear_has_r_str();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int type_;
  bool r_bool_;
  double r_num_;
  ::google::protobuf::internal::ArenaStringPtr r_str_;
  ::google::protobuf::RepeatedPtrField< ::Datum > r_array_;
  ::google::protobuf::RepeatedPtrField< ::Datum_AssocPair > r_object_;
  friend void  protobuf_AddDesc_rdb_5fprotocol_2fql2_2eproto();
  friend void protobuf_AssignDesc_rdb_5fprotocol_2fql2_2eproto();
  friend void protobuf_ShutdownFile_rdb_5fprotocol_2fql2_2eproto();

  void InitAsDefaultInstance();
  static Datum* default_instance_;
};
// -------------------------------------------------------------------

class Term_AssocPair : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Term.AssocPair) */ {
 public:
  Term_AssocPair();
  virtual ~Term_AssocPair();

  Term_AssocPair(const Term_AssocPair& from);

  inline Term_AssocPair& operator=(const Term_AssocPair& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Term_AssocPair& default_instance();

  void Swap(Term_AssocPair* other);

  // implements Message ----------------------------------------------

  inline Term_AssocPair* New() const { return New(NULL); }

  Term_AssocPair* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Term_AssocPair& from);
  void MergeFrom(const Term_AssocPair& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Term_AssocPair* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string key = 1;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // optional .Term val = 2;
  bool has_val() const;
  void clear_val();
  static const int kValFieldNumber = 2;
  const ::Term& val() const;
  ::Term* mutable_val();
  ::Term* release_val();
  void set_allocated_val(::Term* val);

  // @@protoc_insertion_point(class_scope:Term.AssocPair)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_val();
  inline void clear_has_val();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::Term* val_;
  friend void  protobuf_AddDesc_rdb_5fprotocol_2fql2_2eproto();
  friend void protobuf_AssignDesc_rdb_5fprotocol_2fql2_2eproto();
  friend void protobuf_ShutdownFile_rdb_5fprotocol_2fql2_2eproto();

  void InitAsDefaultInstance();
  static Term_AssocPair* default_instance_;
};
// -------------------------------------------------------------------

class Term : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Term) */ {
 public:
  Term();
  virtual ~Term();

  Term(const Term& from);

  inline Term& operator=(const Term& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Term& default_instance();

  void Swap(Term* other);

  // implements Message ----------------------------------------------

  inline Term* New() const { return New(NULL); }

  Term* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Term& from);
  void MergeFrom(const Term& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Term* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Term_AssocPair AssocPair;

  typedef Term_TermType TermType;
  static const TermType DATUM =
    Term_TermType_DATUM;
  static const TermType MAKE_ARRAY =
    Term_TermType_MAKE_ARRAY;
  static const TermType MAKE_OBJ =
    Term_TermType_MAKE_OBJ;
  static const TermType VAR =
    Term_TermType_VAR;
  static const TermType JAVASCRIPT =
    Term_TermType_JAVASCRIPT;
  static const TermType UUID =
    Term_TermType_UUID;
  static const TermType HTTP =
    Term_TermType_HTTP;
  static const TermType ERROR =
    Term_TermType_ERROR;
  static const TermType IMPLICIT_VAR =
    Term_TermType_IMPLICIT_VAR;
  static const TermType DB =
    Term_TermType_DB;
  static const TermType TABLE =
    Term_TermType_TABLE;
  static const TermType GET =
    Term_TermType_GET;
  static const TermType GET_ALL =
    Term_TermType_GET_ALL;
  static const TermType EQ =
    Term_TermType_EQ;
  static const TermType NE =
    Term_TermType_NE;
  static const TermType LT =
    Term_TermType_LT;
  static const TermType LE =
    Term_TermType_LE;
  static const TermType GT =
    Term_TermType_GT;
  static const TermType GE =
    Term_TermType_GE;
  static const TermType NOT =
    Term_TermType_NOT;
  static const TermType ADD =
    Term_TermType_ADD;
  static const TermType SUB =
    Term_TermType_SUB;
  static const TermType MUL =
    Term_TermType_MUL;
  static const TermType DIV =
    Term_TermType_DIV;
  static const TermType MOD =
    Term_TermType_MOD;
  static const TermType FLOOR =
    Term_TermType_FLOOR;
  static const TermType CEIL =
    Term_TermType_CEIL;
  static const TermType ROUND =
    Term_TermType_ROUND;
  static const TermType APPEND =
    Term_TermType_APPEND;
  static const TermType PREPEND =
    Term_TermType_PREPEND;
  static const TermType DIFFERENCE =
    Term_TermType_DIFFERENCE;
  static const TermType SET_INSERT =
    Term_TermType_SET_INSERT;
  static const TermType SET_INTERSECTION =
    Term_TermType_SET_INTERSECTION;
  static const TermType SET_UNION =
    Term_TermType_SET_UNION;
  static const TermType SET_DIFFERENCE =
    Term_TermType_SET_DIFFERENCE;
  static const TermType SLICE =
    Term_TermType_SLICE;
  static const TermType SKIP =
    Term_TermType_SKIP;
  static const TermType LIMIT =
    Term_TermType_LIMIT;
  static const TermType OFFSETS_OF =
    Term_TermType_OFFSETS_OF;
  static const TermType CONTAINS =
    Term_TermType_CONTAINS;
  static const TermType GET_FIELD =
    Term_TermType_GET_FIELD;
  static const TermType KEYS =
    Term_TermType_KEYS;
  static const TermType VALUES =
    Term_TermType_VALUES;
  static const TermType OBJECT =
    Term_TermType_OBJECT;
  static const TermType HAS_FIELDS =
    Term_TermType_HAS_FIELDS;
  static const TermType WITH_FIELDS =
    Term_TermType_WITH_FIELDS;
  static const TermType PLUCK =
    Term_TermType_PLUCK;
  static const TermType WITHOUT =
    Term_TermType_WITHOUT;
  static const TermType MERGE =
    Term_TermType_MERGE;
  static const TermType BETWEEN_DEPRECATED =
    Term_TermType_BETWEEN_DEPRECATED;
  static const TermType BETWEEN =
    Term_TermType_BETWEEN;
  static const TermType REDUCE =
    Term_TermType_REDUCE;
  static const TermType MAP =
    Term_TermType_MAP;
  static const TermType FOLD =
    Term_TermType_FOLD;
  static const TermType FILTER =
    Term_TermType_FILTER;
  static const TermType CONCAT_MAP =
    Term_TermType_CONCAT_MAP;
  static const TermType ORDER_BY =
    Term_TermType_ORDER_BY;
  static const TermType DISTINCT =
    Term_TermType_DISTINCT;
  static const TermType COUNT =
    Term_TermType_COUNT;
  static const TermType IS_EMPTY =
    Term_TermType_IS_EMPTY;
  static const TermType UNION =
    Term_TermType_UNION;
  static const TermType NTH =
    Term_TermType_NTH;
  static const TermType BRACKET =
    Term_TermType_BRACKET;
  static const TermType INNER_JOIN =
    Term_TermType_INNER_JOIN;
  static const TermType OUTER_JOIN =
    Term_TermType_OUTER_JOIN;
  static const TermType EQ_JOIN =
    Term_TermType_EQ_JOIN;
  static const TermType ZIP =
    Term_TermType_ZIP;
  static const TermType RANGE =
    Term_TermType_RANGE;
  static const TermType INSERT_AT =
    Term_TermType_INSERT_AT;
  static const TermType DELETE_AT =
    Term_TermType_DELETE_AT;
  static const TermType CHANGE_AT =
    Term_TermType_CHANGE_AT;
  static const TermType SPLICE_AT =
    Term_TermType_SPLICE_AT;
  static const TermType COERCE_TO =
    Term_TermType_COERCE_TO;
  static const TermType TYPE_OF =
    Term_TermType_TYPE_OF;
  static const TermType UPDATE =
    Term_TermType_UPDATE;
  static const TermType DELETE =
    Term_TermType_DELETE;
  static const TermType REPLACE =
    Term_TermType_REPLACE;
  static const TermType INSERT =
    Term_TermType_INSERT;
  static const TermType DB_CREATE =
    Term_TermType_DB_CREATE;
  static const TermType DB_DROP =
    Term_TermType_DB_DROP;
  static const TermType DB_LIST =
    Term_TermType_DB_LIST;
  static const TermType TABLE_CREATE =
    Term_TermType_TABLE_CREATE;
  static const TermType TABLE_DROP =
    Term_TermType_TABLE_DROP;
  static const TermType TABLE_LIST =
    Term_TermType_TABLE_LIST;
  static const TermType CONFIG =
    Term_TermType_CONFIG;
  static const TermType STATUS =
    Term_TermType_STATUS;
  static const TermType WAIT =
    Term_TermType_WAIT;
  static const TermType RECONFIGURE =
    Term_TermType_RECONFIGURE;
  static const TermType REBALANCE =
    Term_TermType_REBALANCE;
  static const TermType SYNC =
    Term_TermType_SYNC;
  static const TermType GRANT =
    Term_TermType_GRANT;
  static const TermType INDEX_CREATE =
    Term_TermType_INDEX_CREATE;
  static const TermType INDEX_DROP =
    Term_TermType_INDEX_DROP;
  static const TermType INDEX_LIST =
    Term_TermType_INDEX_LIST;
  static const TermType INDEX_STATUS =
    Term_TermType_INDEX_STATUS;
  static const TermType INDEX_WAIT =
    Term_TermType_INDEX_WAIT;
  static const TermType INDEX_RENAME =
    Term_TermType_INDEX_RENAME;
  static const TermType SET_WRITE_HOOK =
    Term_TermType_SET_WRITE_HOOK;
  static const TermType GET_WRITE_HOOK =
    Term_TermType_GET_WRITE_HOOK;
  static const TermType FUNCALL =
    Term_TermType_FUNCALL;
  static const TermType BRANCH =
    Term_TermType_BRANCH;
  static const TermType OR =
    Term_TermType_OR;
  static const TermType AND =
    Term_TermType_AND;
  static const TermType FOR_EACH =
    Term_TermType_FOR_EACH;
  static const TermType FUNC =
    Term_TermType_FUNC;
  static const TermType ASC =
    Term_TermType_ASC;
  static const TermType DESC =
    Term_TermType_DESC;
  static const TermType INFO =
    Term_TermType_INFO;
  static const TermType MATCH =
    Term_TermType_MATCH;
  static const TermType UPCASE =
    Term_TermType_UPCASE;
  static const TermType DOWNCASE =
    Term_TermType_DOWNCASE;
  static const TermType SAMPLE =
    Term_TermType_SAMPLE;
  static const TermType DEFAULT =
    Term_TermType_DEFAULT;
  static const TermType JSON =
    Term_TermType_JSON;
  static const TermType ISO8601 =
    Term_TermType_ISO8601;
  static const TermType TO_ISO8601 =
    Term_TermType_TO_ISO8601;
  static const TermType EPOCH_TIME =
    Term_TermType_EPOCH_TIME;
  static const TermType TO_EPOCH_TIME =
    Term_TermType_TO_EPOCH_TIME;
  static const TermType NOW =
    Term_TermType_NOW;
  static const TermType IN_TIMEZONE =
    Term_TermType_IN_TIMEZONE;
  static const TermType DURING =
    Term_TermType_DURING;
  static const TermType DATE =
    Term_TermType_DATE;
  static const TermType TIME_OF_DAY =
    Term_TermType_TIME_OF_DAY;
  static const TermType TIMEZONE =
    Term_TermType_TIMEZONE;
  static const TermType YEAR =
    Term_TermType_YEAR;
  static const TermType MONTH =
    Term_TermType_MONTH;
  static const TermType DAY =
    Term_TermType_DAY;
  static const TermType DAY_OF_WEEK =
    Term_TermType_DAY_OF_WEEK;
  static const TermType DAY_OF_YEAR =
    Term_TermType_DAY_OF_YEAR;
  static const TermType HOURS =
    Term_TermType_HOURS;
  static const TermType MINUTES =
    Term_TermType_MINUTES;
  static const TermType SECONDS =
    Term_TermType_SECONDS;
  static const TermType TIME =
    Term_TermType_TIME;
  static const TermType MONDAY =
    Term_TermType_MONDAY;
  static const TermType TUESDAY =
    Term_TermType_TUESDAY;
  static const TermType WEDNESDAY =
    Term_TermType_WEDNESDAY;
  static const TermType THURSDAY =
    Term_TermType_THURSDAY;
  static const TermType FRIDAY =
    Term_TermType_FRIDAY;
  static const TermType SATURDAY =
    Term_TermType_SATURDAY;
  static const TermType SUNDAY =
    Term_TermType_SUNDAY;
  static const TermType JANUARY =
    Term_TermType_JANUARY;
  static const TermType FEBRUARY =
    Term_TermType_FEBRUARY;
  static const TermType MARCH =
    Term_TermType_MARCH;
  static const TermType APRIL =
    Term_TermType_APRIL;
  static const TermType MAY =
    Term_TermType_MAY;
  static const TermType JUNE =
    Term_TermType_JUNE;
  static const TermType JULY =
    Term_TermType_JULY;
  static const TermType AUGUST =
    Term_TermType_AUGUST;
  static const TermType SEPTEMBER =
    Term_TermType_SEPTEMBER;
  static const TermType OCTOBER =
    Term_TermType_OCTOBER;
  static const TermType NOVEMBER =
    Term_TermType_NOVEMBER;
  static const TermType DECEMBER =
    Term_TermType_DECEMBER;
  static const TermType LITERAL =
    Term_TermType_LITERAL;
  static const TermType GROUP =
    Term_TermType_GROUP;
  static const TermType SUM =
    Term_TermType_SUM;
  static const TermType AVG =
    Term_TermType_AVG;
  static const TermType MIN =
    Term_TermType_MIN;
  static const TermType MAX =
    Term_TermType_MAX;
  static const TermType SPLIT =
    Term_TermType_SPLIT;
  static const TermType UNGROUP =
    Term_TermType_UNGROUP;
  static const TermType RANDOM =
    Term_TermType_RANDOM;
  static const TermType CHANGES =
    Term_TermType_CHANGES;
  static const TermType ARGS =
    Term_TermType_ARGS;
  static const TermType BINARY =
    Term_TermType_BINARY;
  static const TermType GEOJSON =
    Term_TermType_GEOJSON;
  static const TermType TO_GEOJSON =
    Term_TermType_TO_GEOJSON;
  static const TermType POINT =
    Term_TermType_POINT;
  static const TermType LINE =
    Term_TermType_LINE;
  static const TermType POLYGON =
    Term_TermType_POLYGON;
  static const TermType DISTANCE =
    Term_TermType_DISTANCE;
  static const TermType INTERSECTS =
    Term_TermType_INTERSECTS;
  static const TermType INCLUDES =
    Term_TermType_INCLUDES;
  static const TermType CIRCLE =
    Term_TermType_CIRCLE;
  static const TermType GET_INTERSECTING =
    Term_TermType_GET_INTERSECTING;
  static const TermType FILL =
    Term_TermType_FILL;
  static const TermType GET_NEAREST =
    Term_TermType_GET_NEAREST;
  static const TermType POLYGON_SUB =
    Term_TermType_POLYGON_SUB;
  static const TermType TO_JSON_STRING =
    Term_TermType_TO_JSON_STRING;
  static const TermType MINVAL =
    Term_TermType_MINVAL;
  static const TermType MAXVAL =
    Term_TermType_MAXVAL;
  static const TermType BIT_AND =
    Term_TermType_BIT_AND;
  static const TermType BIT_OR =
    Term_TermType_BIT_OR;
  static const TermType BIT_XOR =
    Term_TermType_BIT_XOR;
  static const TermType BIT_NOT =
    Term_TermType_BIT_NOT;
  static const TermType BIT_SAL =
    Term_TermType_BIT_SAL;
  static const TermType BIT_SAR =
    Term_TermType_BIT_SAR;
  static inline bool TermType_IsValid(int value) {
    return Term_TermType_IsValid(value);
  }
  static const TermType TermType_MIN =
    Term_TermType_TermType_MIN;
  static const TermType TermType_MAX =
    Term_TermType_TermType_MAX;
  static const int TermType_ARRAYSIZE =
    Term_TermType_TermType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  TermType_descriptor() {
    return Term_TermType_descriptor();
  }
  static inline const ::std::string& TermType_Name(TermType value) {
    return Term_TermType_Name(value);
  }
  static inline bool TermType_Parse(const ::std::string& name,
      TermType* value) {
    return Term_TermType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .Term.TermType type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::Term_TermType type() const;
  void set_type(::Term_TermType value);

  // optional .Datum datum = 2;
  bool has_datum() const;
  void clear_datum();
  static const int kDatumFieldNumber = 2;
  const ::Datum& datum() const;
  ::Datum* mutable_datum();
  ::Datum* release_datum();
  void set_allocated_datum(::Datum* datum);

  // repeated .Term args = 3;
  int args_size() const;
  void clear_args();
  static const int kArgsFieldNumber = 3;
  const ::Term& args(int index) const;
  ::Term* mutable_args(int index);
  ::Term* add_args();
  ::google::protobuf::RepeatedPtrField< ::Term >*
      mutable_args();
  const ::google::protobuf::RepeatedPtrField< ::Term >&
      args() const;

  // repeated .Term.AssocPair optargs = 4;
  int optargs_size() const;
  void clear_optargs();
  static const int kOptargsFieldNumber = 4;
  const ::Term_AssocPair& optargs(int index) const;
  ::Term_AssocPair* mutable_optargs(int index);
  ::Term_AssocPair* add_optargs();
  ::google::protobuf::RepeatedPtrField< ::Term_AssocPair >*
      mutable_optargs();
  const ::google::protobuf::RepeatedPtrField< ::Term_AssocPair >&
      optargs() const;

  // @@protoc_insertion_point(class_scope:Term)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_datum();
  inline void clear_has_datum();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::Datum* datum_;
  ::google::protobuf::RepeatedPtrField< ::Term > args_;
  ::google::protobuf::RepeatedPtrField< ::Term_AssocPair > optargs_;
  int type_;
  friend void  protobuf_AddDesc_rdb_5fprotocol_2fql2_2eproto();
  friend void protobuf_AssignDesc_rdb_5fprotocol_2fql2_2eproto();
  friend void protobuf_ShutdownFile_rdb_5fprotocol_2fql2_2eproto();

  void InitAsDefaultInstance();
  static Term* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// VersionDummy

// -------------------------------------------------------------------

// Query_AssocPair

// optional string key = 1;
inline bool Query_AssocPair::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Query_AssocPair::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Query_AssocPair::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Query_AssocPair::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_key();
}
inline const ::std::string& Query_AssocPair::key() const {
  // @@protoc_insertion_point(field_get:Query.AssocPair.key)
  return key_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Query_AssocPair::set_key(const ::std::string& value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Query.AssocPair.key)
}
inline void Query_AssocPair::set_key(const char* value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Query.AssocPair.key)
}
inline void Query_AssocPair::set_key(const char* value, size_t size) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Query.AssocPair.key)
}
inline ::std::string* Query_AssocPair::mutable_key() {
  set_has_key();
  // @@protoc_insertion_point(field_mutable:Query.AssocPair.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Query_AssocPair::release_key() {
  // @@protoc_insertion_point(field_release:Query.AssocPair.key)
  clear_has_key();
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Query_AssocPair::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    set_has_key();
  } else {
    clear_has_key();
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:Query.AssocPair.key)
}

// optional .Term val = 2;
inline bool Query_AssocPair::has_val() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Query_AssocPair::set_has_val() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Query_AssocPair::clear_has_val() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Query_AssocPair::clear_val() {
  if (val_ != NULL) val_->::Term::Clear();
  clear_has_val();
}
inline const ::Term& Query_AssocPair::val() const {
  // @@protoc_insertion_point(field_get:Query.AssocPair.val)
  return val_ != NULL ? *val_ : *default_instance_->val_;
}
inline ::Term* Query_AssocPair::mutable_val() {
  set_has_val();
  if (val_ == NULL) {
    val_ = new ::Term;
  }
  // @@protoc_insertion_point(field_mutable:Query.AssocPair.val)
  return val_;
}
inline ::Term* Query_AssocPair::release_val() {
  // @@protoc_insertion_point(field_release:Query.AssocPair.val)
  clear_has_val();
  ::Term* temp = val_;
  val_ = NULL;
  return temp;
}
inline void Query_AssocPair::set_allocated_val(::Term* val) {
  delete val_;
  val_ = val;
  if (val) {
    set_has_val();
  } else {
    clear_has_val();
  }
  // @@protoc_insertion_point(field_set_allocated:Query.AssocPair.val)
}

// -------------------------------------------------------------------

// Query

// optional .Query.QueryType type = 1;
inline bool Query::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Query::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Query::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Query::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::Query_QueryType Query::type() const {
  // @@protoc_insertion_point(field_get:Query.type)
  return static_cast< ::Query_QueryType >(type_);
}
inline void Query::set_type(::Query_QueryType value) {
  assert(::Query_QueryType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:Query.type)
}

// optional .Term query = 2;
inline bool Query::has_query() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Query::set_has_query() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Query::clear_has_query() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Query::clear_query() {
  if (query_ != NULL) query_->::Term::Clear();
  clear_has_query();
}
inline const ::Term& Query::query() const {
  // @@protoc_insertion_point(field_get:Query.query)
  return query_ != NULL ? *query_ : *default_instance_->query_;
}
inline ::Term* Query::mutable_query() {
  set_has_query();
  if (query_ == NULL) {
    query_ = new ::Term;
  }
  // @@protoc_insertion_point(field_mutable:Query.query)
  return query_;
}
inline ::Term* Query::release_query() {
  // @@protoc_insertion_point(field_release:Query.query)
  clear_has_query();
  ::Term* temp = query_;
  query_ = NULL;
  return temp;
}
inline void Query::set_allocated_query(::Term* query) {
  delete query_;
  query_ = query;
  if (query) {
    set_has_query();
  } else {
    clear_has_query();
  }
  // @@protoc_insertion_point(field_set_allocated:Query.query)
}

// optional int64 token = 3;
inline bool Query::has_token() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Query::set_has_token() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Query::clear_has_token() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Query::clear_token() {
  token_ = GOOGLE_LONGLONG(0);
  clear_has_token();
}
inline ::google::protobuf::int64 Query::token() const {
  // @@protoc_insertion_point(field_get:Query.token)
  return token_;
}
inline void Query::set_token(::google::protobuf::int64 value) {
  set_has_token();
  token_ = value;
  // @@protoc_insertion_point(field_set:Query.token)
}

// optional bool OBSOLETE_noreply = 4 [default = false];
inline bool Query::has_obsolete_noreply() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Query::set_has_obsolete_noreply() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Query::clear_has_obsolete_noreply() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Query::clear_obsolete_noreply() {
  obsolete_noreply_ = false;
  clear_has_obsolete_noreply();
}
inline bool Query::obsolete_noreply() const {
  // @@protoc_insertion_point(field_get:Query.OBSOLETE_noreply)
  return obsolete_noreply_;
}
inline void Query::set_obsolete_noreply(bool value) {
  set_has_obsolete_noreply();
  obsolete_noreply_ = value;
  // @@protoc_insertion_point(field_set:Query.OBSOLETE_noreply)
}

// optional bool accepts_r_json = 5 [default = false];
inline bool Query::has_accepts_r_json() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Query::set_has_accepts_r_json() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Query::clear_has_accepts_r_json() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Query::clear_accepts_r_json() {
  accepts_r_json_ = false;
  clear_has_accepts_r_json();
}
inline bool Query::accepts_r_json() const {
  // @@protoc_insertion_point(field_get:Query.accepts_r_json)
  return accepts_r_json_;
}
inline void Query::set_accepts_r_json(bool value) {
  set_has_accepts_r_json();
  accepts_r_json_ = value;
  // @@protoc_insertion_point(field_set:Query.accepts_r_json)
}

// repeated .Query.AssocPair global_optargs = 6;
inline int Query::global_optargs_size() const {
  return global_optargs_.size();
}
inline void Query::clear_global_optargs() {
  global_optargs_.Clear();
}
inline const ::Query_AssocPair& Query::global_optargs(int index) const {
  // @@protoc_insertion_point(field_get:Query.global_optargs)
  return global_optargs_.Get(index);
}
inline ::Query_AssocPair* Query::mutable_global_optargs(int index) {
  // @@protoc_insertion_point(field_mutable:Query.global_optargs)
  return global_optargs_.Mutable(index);
}
inline ::Query_AssocPair* Query::add_global_optargs() {
  // @@protoc_insertion_point(field_add:Query.global_optargs)
  return global_optargs_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Query_AssocPair >*
Query::mutable_global_optargs() {
  // @@protoc_insertion_point(field_mutable_list:Query.global_optargs)
  return &global_optargs_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Query_AssocPair >&
Query::global_optargs() const {
  // @@protoc_insertion_point(field_list:Query.global_optargs)
  return global_optargs_;
}

// -------------------------------------------------------------------

// Frame

// optional .Frame.FrameType type = 1;
inline bool Frame::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Frame::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Frame::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Frame::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::Frame_FrameType Frame::type() const {
  // @@protoc_insertion_point(field_get:Frame.type)
  return static_cast< ::Frame_FrameType >(type_);
}
inline void Frame::set_type(::Frame_FrameType value) {
  assert(::Frame_FrameType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:Frame.type)
}

// optional int64 pos = 2;
inline bool Frame::has_pos() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Frame::set_has_pos() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Frame::clear_has_pos() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Frame::clear_pos() {
  pos_ = GOOGLE_LONGLONG(0);
  clear_has_pos();
}
inline ::google::protobuf::int64 Frame::pos() const {
  // @@protoc_insertion_point(field_get:Frame.pos)
  return pos_;
}
inline void Frame::set_pos(::google::protobuf::int64 value) {
  set_has_pos();
  pos_ = value;
  // @@protoc_insertion_point(field_set:Frame.pos)
}

// optional string opt = 3;
inline bool Frame::has_opt() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Frame::set_has_opt() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Frame::clear_has_opt() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Frame::clear_opt() {
  opt_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_opt();
}
inline const ::std::string& Frame::opt() const {
  // @@protoc_insertion_point(field_get:Frame.opt)
  return opt_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Frame::set_opt(const ::std::string& value) {
  set_has_opt();
  opt_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Frame.opt)
}
inline void Frame::set_opt(const char* value) {
  set_has_opt();
  opt_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Frame.opt)
}
inline void Frame::set_opt(const char* value, size_t size) {
  set_has_opt();
  opt_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Frame.opt)
}
inline ::std::string* Frame::mutable_opt() {
  set_has_opt();
  // @@protoc_insertion_point(field_mutable:Frame.opt)
  return opt_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Frame::release_opt() {
  // @@protoc_insertion_point(field_release:Frame.opt)
  clear_has_opt();
  return opt_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Frame::set_allocated_opt(::std::string* opt) {
  if (opt != NULL) {
    set_has_opt();
  } else {
    clear_has_opt();
  }
  opt_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), opt);
  // @@protoc_insertion_point(field_set_allocated:Frame.opt)
}

// -------------------------------------------------------------------

// Backtrace

// repeated .Frame frames = 1;
inline int Backtrace::frames_size() const {
  return frames_.size();
}
inline void Backtrace::clear_frames() {
  frames_.Clear();
}
inline const ::Frame& Backtrace::frames(int index) const {
  // @@protoc_insertion_point(field_get:Backtrace.frames)
  return frames_.Get(index);
}
inline ::Frame* Backtrace::mutable_frames(int index) {
  // @@protoc_insertion_point(field_mutable:Backtrace.frames)
  return frames_.Mutable(index);
}
inline ::Frame* Backtrace::add_frames() {
  // @@protoc_insertion_point(field_add:Backtrace.frames)
  return frames_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Frame >*
Backtrace::mutable_frames() {
  // @@protoc_insertion_point(field_mutable_list:Backtrace.frames)
  return &frames_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Frame >&
Backtrace::frames() const {
  // @@protoc_insertion_point(field_list:Backtrace.frames)
  return frames_;
}

// -------------------------------------------------------------------

// Response

// optional .Response.ResponseType type = 1;
inline bool Response::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Response::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Response::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Response::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::Response_ResponseType Response::type() const {
  // @@protoc_insertion_point(field_get:Response.type)
  return static_cast< ::Response_ResponseType >(type_);
}
inline void Response::set_type(::Response_ResponseType value) {
  assert(::Response_ResponseType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:Response.type)
}

// optional .Response.ErrorType error_type = 7;
inline bool Response::has_error_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Response::set_has_error_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Response::clear_has_error_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Response::clear_error_type() {
  error_type_ = 1000000;
  clear_has_error_type();
}
inline ::Response_ErrorType Response::error_type() const {
  // @@protoc_insertion_point(field_get:Response.error_type)
  return static_cast< ::Response_ErrorType >(error_type_);
}
inline void Response::set_error_type(::Response_ErrorType value) {
  assert(::Response_ErrorType_IsValid(value));
  set_has_error_type();
  error_type_ = value;
  // @@protoc_insertion_point(field_set:Response.error_type)
}

// repeated .Response.ResponseNote notes = 6;
inline int Response::notes_size() const {
  return notes_.size();
}
inline void Response::clear_notes() {
  notes_.Clear();
}
inline ::Response_ResponseNote Response::notes(int index) const {
  // @@protoc_insertion_point(field_get:Response.notes)
  return static_cast< ::Response_ResponseNote >(notes_.Get(index));
}
inline void Response::set_notes(int index, ::Response_ResponseNote value) {
  assert(::Response_ResponseNote_IsValid(value));
  notes_.Set(index, value);
  // @@protoc_insertion_point(field_set:Response.notes)
}
inline void Response::add_notes(::Response_ResponseNote value) {
  assert(::Response_ResponseNote_IsValid(value));
  notes_.Add(value);
  // @@protoc_insertion_point(field_add:Response.notes)
}
inline const ::google::protobuf::RepeatedField<int>&
Response::notes() const {
  // @@protoc_insertion_point(field_list:Response.notes)
  return notes_;
}
inline ::google::protobuf::RepeatedField<int>*
Response::mutable_notes() {
  // @@protoc_insertion_point(field_mutable_list:Response.notes)
  return &notes_;
}

// optional int64 token = 2;
inline bool Response::has_token() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Response::set_has_token() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Response::clear_has_token() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Response::clear_token() {
  token_ = GOOGLE_LONGLONG(0);
  clear_has_token();
}
inline ::google::protobuf::int64 Response::token() const {
  // @@protoc_insertion_point(field_get:Response.token)
  return token_;
}
inline void Response::set_token(::google::protobuf::int64 value) {
  set_has_token();
  token_ = value;
  // @@protoc_insertion_point(field_set:Response.token)
}

// repeated .Datum response = 3;
inline int Response::response_size() const {
  return response_.size();
}
inline void Response::clear_response() {
  response_.Clear();
}
inline const ::Datum& Response::response(int index) const {
  // @@protoc_insertion_point(field_get:Response.response)
  return response_.Get(index);
}
inline ::Datum* Response::mutable_response(int index) {
  // @@protoc_insertion_point(field_mutable:Response.response)
  return response_.Mutable(index);
}
inline ::Datum* Response::add_response() {
  // @@protoc_insertion_point(field_add:Response.response)
  return response_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Datum >*
Response::mutable_response() {
  // @@protoc_insertion_point(field_mutable_list:Response.response)
  return &response_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Datum >&
Response::response() const {
  // @@protoc_insertion_point(field_list:Response.response)
  return response_;
}

// optional .Backtrace backtrace = 4;
inline bool Response::has_backtrace() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Response::set_has_backtrace() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Response::clear_has_backtrace() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Response::clear_backtrace() {
  if (backtrace_ != NULL) backtrace_->::Backtrace::Clear();
  clear_has_backtrace();
}
inline const ::Backtrace& Response::backtrace() const {
  // @@protoc_insertion_point(field_get:Response.backtrace)
  return backtrace_ != NULL ? *backtrace_ : *default_instance_->backtrace_;
}
inline ::Backtrace* Response::mutable_backtrace() {
  set_has_backtrace();
  if (backtrace_ == NULL) {
    backtrace_ = new ::Backtrace;
  }
  // @@protoc_insertion_point(field_mutable:Response.backtrace)
  return backtrace_;
}
inline ::Backtrace* Response::release_backtrace() {
  // @@protoc_insertion_point(field_release:Response.backtrace)
  clear_has_backtrace();
  ::Backtrace* temp = backtrace_;
  backtrace_ = NULL;
  return temp;
}
inline void Response::set_allocated_backtrace(::Backtrace* backtrace) {
  delete backtrace_;
  backtrace_ = backtrace;
  if (backtrace) {
    set_has_backtrace();
  } else {
    clear_has_backtrace();
  }
  // @@protoc_insertion_point(field_set_allocated:Response.backtrace)
}

// optional .Datum profile = 5;
inline bool Response::has_profile() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Response::set_has_profile() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Response::clear_has_profile() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Response::clear_profile() {
  if (profile_ != NULL) profile_->::Datum::Clear();
  clear_has_profile();
}
inline const ::Datum& Response::profile() const {
  // @@protoc_insertion_point(field_get:Response.profile)
  return profile_ != NULL ? *profile_ : *default_instance_->profile_;
}
inline ::Datum* Response::mutable_profile() {
  set_has_profile();
  if (profile_ == NULL) {
    profile_ = new ::Datum;
  }
  // @@protoc_insertion_point(field_mutable:Response.profile)
  return profile_;
}
inline ::Datum* Response::release_profile() {
  // @@protoc_insertion_point(field_release:Response.profile)
  clear_has_profile();
  ::Datum* temp = profile_;
  profile_ = NULL;
  return temp;
}
inline void Response::set_allocated_profile(::Datum* profile) {
  delete profile_;
  profile_ = profile;
  if (profile) {
    set_has_profile();
  } else {
    clear_has_profile();
  }
  // @@protoc_insertion_point(field_set_allocated:Response.profile)
}

// -------------------------------------------------------------------

// Datum_AssocPair

// optional string key = 1;
inline bool Datum_AssocPair::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Datum_AssocPair::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Datum_AssocPair::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Datum_AssocPair::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_key();
}
inline const ::std::string& Datum_AssocPair::key() const {
  // @@protoc_insertion_point(field_get:Datum.AssocPair.key)
  return key_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Datum_AssocPair::set_key(const ::std::string& value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Datum.AssocPair.key)
}
inline void Datum_AssocPair::set_key(const char* value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Datum.AssocPair.key)
}
inline void Datum_AssocPair::set_key(const char* value, size_t size) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Datum.AssocPair.key)
}
inline ::std::string* Datum_AssocPair::mutable_key() {
  set_has_key();
  // @@protoc_insertion_point(field_mutable:Datum.AssocPair.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Datum_AssocPair::release_key() {
  // @@protoc_insertion_point(field_release:Datum.AssocPair.key)
  clear_has_key();
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Datum_AssocPair::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    set_has_key();
  } else {
    clear_has_key();
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:Datum.AssocPair.key)
}

// optional .Datum val = 2;
inline bool Datum_AssocPair::has_val() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Datum_AssocPair::set_has_val() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Datum_AssocPair::clear_has_val() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Datum_AssocPair::clear_val() {
  if (val_ != NULL) val_->::Datum::Clear();
  clear_has_val();
}
inline const ::Datum& Datum_AssocPair::val() const {
  // @@protoc_insertion_point(field_get:Datum.AssocPair.val)
  return val_ != NULL ? *val_ : *default_instance_->val_;
}
inline ::Datum* Datum_AssocPair::mutable_val() {
  set_has_val();
  if (val_ == NULL) {
    val_ = new ::Datum;
  }
  // @@protoc_insertion_point(field_mutable:Datum.AssocPair.val)
  return val_;
}
inline ::Datum* Datum_AssocPair::release_val() {
  // @@protoc_insertion_point(field_release:Datum.AssocPair.val)
  clear_has_val();
  ::Datum* temp = val_;
  val_ = NULL;
  return temp;
}
inline void Datum_AssocPair::set_allocated_val(::Datum* val) {
  delete val_;
  val_ = val;
  if (val) {
    set_has_val();
  } else {
    clear_has_val();
  }
  // @@protoc_insertion_point(field_set_allocated:Datum.AssocPair.val)
}

// -------------------------------------------------------------------

// Datum

// optional .Datum.DatumType type = 1;
inline bool Datum::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Datum::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Datum::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Datum::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::Datum_DatumType Datum::type() const {
  // @@protoc_insertion_point(field_get:Datum.type)
  return static_cast< ::Datum_DatumType >(type_);
}
inline void Datum::set_type(::Datum_DatumType value) {
  assert(::Datum_DatumType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:Datum.type)
}

// optional bool r_bool = 2;
inline bool Datum::has_r_bool() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Datum::set_has_r_bool() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Datum::clear_has_r_bool() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Datum::clear_r_bool() {
  r_bool_ = false;
  clear_has_r_bool();
}
inline bool Datum::r_bool() const {
  // @@protoc_insertion_point(field_get:Datum.r_bool)
  return r_bool_;
}
inline void Datum::set_r_bool(bool value) {
  set_has_r_bool();
  r_bool_ = value;
  // @@protoc_insertion_point(field_set:Datum.r_bool)
}

// optional double r_num = 3;
inline bool Datum::has_r_num() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Datum::set_has_r_num() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Datum::clear_has_r_num() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Datum::clear_r_num() {
  r_num_ = 0;
  clear_has_r_num();
}
inline double Datum::r_num() const {
  // @@protoc_insertion_point(field_get:Datum.r_num)
  return r_num_;
}
inline void Datum::set_r_num(double value) {
  set_has_r_num();
  r_num_ = value;
  // @@protoc_insertion_point(field_set:Datum.r_num)
}

// optional string r_str = 4;
inline bool Datum::has_r_str() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Datum::set_has_r_str() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Datum::clear_has_r_str() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Datum::clear_r_str() {
  r_str_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_r_str();
}
inline const ::std::string& Datum::r_str() const {
  // @@protoc_insertion_point(field_get:Datum.r_str)
  return r_str_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Datum::set_r_str(const ::std::string& value) {
  set_has_r_str();
  r_str_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Datum.r_str)
}
inline void Datum::set_r_str(const char* value) {
  set_has_r_str();
  r_str_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Datum.r_str)
}
inline void Datum::set_r_str(const char* value, size_t size) {
  set_has_r_str();
  r_str_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Datum.r_str)
}
inline ::std::string* Datum::mutable_r_str() {
  set_has_r_str();
  // @@protoc_insertion_point(field_mutable:Datum.r_str)
  return r_str_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Datum::release_r_str() {
  // @@protoc_insertion_point(field_release:Datum.r_str)
  clear_has_r_str();
  return r_str_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Datum::set_allocated_r_str(::std::string* r_str) {
  if (r_str != NULL) {
    set_has_r_str();
  } else {
    clear_has_r_str();
  }
  r_str_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), r_str);
  // @@protoc_insertion_point(field_set_allocated:Datum.r_str)
}

// repeated .Datum r_array = 5;
inline int Datum::r_array_size() const {
  return r_array_.size();
}
inline void Datum::clear_r_array() {
  r_array_.Clear();
}
inline const ::Datum& Datum::r_array(int index) const {
  // @@protoc_insertion_point(field_get:Datum.r_array)
  return r_array_.Get(index);
}
inline ::Datum* Datum::mutable_r_array(int index) {
  // @@protoc_insertion_point(field_mutable:Datum.r_array)
  return r_array_.Mutable(index);
}
inline ::Datum* Datum::add_r_array() {
  // @@protoc_insertion_point(field_add:Datum.r_array)
  return r_array_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Datum >*
Datum::mutable_r_array() {
  // @@protoc_insertion_point(field_mutable_list:Datum.r_array)
  return &r_array_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Datum >&
Datum::r_array() const {
  // @@protoc_insertion_point(field_list:Datum.r_array)
  return r_array_;
}

// repeated .Datum.AssocPair r_object = 6;
inline int Datum::r_object_size() const {
  return r_object_.size();
}
inline void Datum::clear_r_object() {
  r_object_.Clear();
}
inline const ::Datum_AssocPair& Datum::r_object(int index) const {
  // @@protoc_insertion_point(field_get:Datum.r_object)
  return r_object_.Get(index);
}
inline ::Datum_AssocPair* Datum::mutable_r_object(int index) {
  // @@protoc_insertion_point(field_mutable:Datum.r_object)
  return r_object_.Mutable(index);
}
inline ::Datum_AssocPair* Datum::add_r_object() {
  // @@protoc_insertion_point(field_add:Datum.r_object)
  return r_object_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Datum_AssocPair >*
Datum::mutable_r_object() {
  // @@protoc_insertion_point(field_mutable_list:Datum.r_object)
  return &r_object_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Datum_AssocPair >&
Datum::r_object() const {
  // @@protoc_insertion_point(field_list:Datum.r_object)
  return r_object_;
}

// -------------------------------------------------------------------

// Term_AssocPair

// optional string key = 1;
inline bool Term_AssocPair::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Term_AssocPair::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Term_AssocPair::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Term_AssocPair::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_key();
}
inline const ::std::string& Term_AssocPair::key() const {
  // @@protoc_insertion_point(field_get:Term.AssocPair.key)
  return key_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Term_AssocPair::set_key(const ::std::string& value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Term.AssocPair.key)
}
inline void Term_AssocPair::set_key(const char* value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Term.AssocPair.key)
}
inline void Term_AssocPair::set_key(const char* value, size_t size) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Term.AssocPair.key)
}
inline ::std::string* Term_AssocPair::mutable_key() {
  set_has_key();
  // @@protoc_insertion_point(field_mutable:Term.AssocPair.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Term_AssocPair::release_key() {
  // @@protoc_insertion_point(field_release:Term.AssocPair.key)
  clear_has_key();
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Term_AssocPair::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    set_has_key();
  } else {
    clear_has_key();
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:Term.AssocPair.key)
}

// optional .Term val = 2;
inline bool Term_AssocPair::has_val() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Term_AssocPair::set_has_val() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Term_AssocPair::clear_has_val() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Term_AssocPair::clear_val() {
  if (val_ != NULL) val_->::Term::Clear();
  clear_has_val();
}
inline const ::Term& Term_AssocPair::val() const {
  // @@protoc_insertion_point(field_get:Term.AssocPair.val)
  return val_ != NULL ? *val_ : *default_instance_->val_;
}
inline ::Term* Term_AssocPair::mutable_val() {
  set_has_val();
  if (val_ == NULL) {
    val_ = new ::Term;
  }
  // @@protoc_insertion_point(field_mutable:Term.AssocPair.val)
  return val_;
}
inline ::Term* Term_AssocPair::release_val() {
  // @@protoc_insertion_point(field_release:Term.AssocPair.val)
  clear_has_val();
  ::Term* temp = val_;
  val_ = NULL;
  return temp;
}
inline void Term_AssocPair::set_allocated_val(::Term* val) {
  delete val_;
  val_ = val;
  if (val) {
    set_has_val();
  } else {
    clear_has_val();
  }
  // @@protoc_insertion_point(field_set_allocated:Term.AssocPair.val)
}

// -------------------------------------------------------------------

// Term

// optional .Term.TermType type = 1;
inline bool Term::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Term::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Term::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Term::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::Term_TermType Term::type() const {
  // @@protoc_insertion_point(field_get:Term.type)
  return static_cast< ::Term_TermType >(type_);
}
inline void Term::set_type(::Term_TermType value) {
  assert(::Term_TermType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:Term.type)
}

// optional .Datum datum = 2;
inline bool Term::has_datum() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Term::set_has_datum() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Term::clear_has_datum() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Term::clear_datum() {
  if (datum_ != NULL) datum_->::Datum::Clear();
  clear_has_datum();
}
inline const ::Datum& Term::datum() const {
  // @@protoc_insertion_point(field_get:Term.datum)
  return datum_ != NULL ? *datum_ : *default_instance_->datum_;
}
inline ::Datum* Term::mutable_datum() {
  set_has_datum();
  if (datum_ == NULL) {
    datum_ = new ::Datum;
  }
  // @@protoc_insertion_point(field_mutable:Term.datum)
  return datum_;
}
inline ::Datum* Term::release_datum() {
  // @@protoc_insertion_point(field_release:Term.datum)
  clear_has_datum();
  ::Datum* temp = datum_;
  datum_ = NULL;
  return temp;
}
inline void Term::set_allocated_datum(::Datum* datum) {
  delete datum_;
  datum_ = datum;
  if (datum) {
    set_has_datum();
  } else {
    clear_has_datum();
  }
  // @@protoc_insertion_point(field_set_allocated:Term.datum)
}

// repeated .Term args = 3;
inline int Term::args_size() const {
  return args_.size();
}
inline void Term::clear_args() {
  args_.Clear();
}
inline const ::Term& Term::args(int index) const {
  // @@protoc_insertion_point(field_get:Term.args)
  return args_.Get(index);
}
inline ::Term* Term::mutable_args(int index) {
  // @@protoc_insertion_point(field_mutable:Term.args)
  return args_.Mutable(index);
}
inline ::Term* Term::add_args() {
  // @@protoc_insertion_point(field_add:Term.args)
  return args_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Term >*
Term::mutable_args() {
  // @@protoc_insertion_point(field_mutable_list:Term.args)
  return &args_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Term >&
Term::args() const {
  // @@protoc_insertion_point(field_list:Term.args)
  return args_;
}

// repeated .Term.AssocPair optargs = 4;
inline int Term::optargs_size() const {
  return optargs_.size();
}
inline void Term::clear_optargs() {
  optargs_.Clear();
}
inline const ::Term_AssocPair& Term::optargs(int index) const {
  // @@protoc_insertion_point(field_get:Term.optargs)
  return optargs_.Get(index);
}
inline ::Term_AssocPair* Term::mutable_optargs(int index) {
  // @@protoc_insertion_point(field_mutable:Term.optargs)
  return optargs_.Mutable(index);
}
inline ::Term_AssocPair* Term::add_optargs() {
  // @@protoc_insertion_point(field_add:Term.optargs)
  return optargs_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Term_AssocPair >*
Term::mutable_optargs() {
  // @@protoc_insertion_point(field_mutable_list:Term.optargs)
  return &optargs_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Term_AssocPair >&
Term::optargs() const {
  // @@protoc_insertion_point(field_list:Term.optargs)
  return optargs_;
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::VersionDummy_Version> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::VersionDummy_Version>() {
  return ::VersionDummy_Version_descriptor();
}
template <> struct is_proto_enum< ::VersionDummy_Protocol> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::VersionDummy_Protocol>() {
  return ::VersionDummy_Protocol_descriptor();
}
template <> struct is_proto_enum< ::Query_QueryType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Query_QueryType>() {
  return ::Query_QueryType_descriptor();
}
template <> struct is_proto_enum< ::Frame_FrameType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Frame_FrameType>() {
  return ::Frame_FrameType_descriptor();
}
template <> struct is_proto_enum< ::Response_ResponseType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Response_ResponseType>() {
  return ::Response_ResponseType_descriptor();
}
template <> struct is_proto_enum< ::Response_ErrorType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Response_ErrorType>() {
  return ::Response_ErrorType_descriptor();
}
template <> struct is_proto_enum< ::Response_ResponseNote> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Response_ResponseNote>() {
  return ::Response_ResponseNote_descriptor();
}
template <> struct is_proto_enum< ::Datum_DatumType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Datum_DatumType>() {
  return ::Datum_DatumType_descriptor();
}
template <> struct is_proto_enum< ::Term_TermType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Term_TermType>() {
  return ::Term_TermType_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_rdb_5fprotocol_2fql2_2eproto__INCLUDED
